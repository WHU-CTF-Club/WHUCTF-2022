#get_my_number
    nc连上去,然后看看源代码，是int溢出的问题,我输入的是一个负数,这样就可以得到shell啦,在用find命令和cat命令最后就能成功得到flag,~~没啥好说的~~.
#NO_COPY
    签到题目,不好说.打开网页源码复制那一段内容再粘贴到word打开就行.
#sign_in
    略
#rack your brain
    这种编码格式是与佛论禅和brainfuck的结合,~~网上找到能用的在线解码器即可~~
#thin_dog
    淦，纯属欺负英语菜狗.我是用au打开,直接毙掉头疼的右声道,然后在明白了这是无线电字母读法之后再配合谷歌翻译的音频功能就做出来了.
#小紫
    出题人成分复杂,我不好说.用winhex打开第一张图片,然后随便改宽高啊,因为是png,不影响.得到password后可以结合hint和东方厨出题人的解释,第二张图片也是宽高隐写术.然后使用010editor打开,惊喜发现这不能随便改宽高,因为是bmp格式的,但是可以改成原始宽高,该bmp是32位的,总字节数减掉头文件大小（138）,因为24位是1个像素3个字节，因此32位是1个像素4个字节.除以4后，再除以宽,得到高1876,直接用010editor的模块进行改写,可以避免浏览二进制.然后flag就出现在了右上角.
#wingman
    ~~这道题纯属ex人~~
    打开谷歌识图,一开始我判断这是在奥尔良,然后我跑去问yl学长,他告诉我不是,但是多方信息都表明应该是奥尔良,只可惜奥尔良没有海底捞,因此我摆了好几天.
    通过谷歌搜索图片中出现的店名，发现照片是在环球影城中拍的,应该是模仿某部电影的取景地.环球影城全球没有几个,用谷歌地球找到环球影城,因为后来yl学长说不在美利坚,直接看新加坡和大阪就行了.经过仔细核对,照片中的有两棵树和大阪的街景对上了.因此是大阪.然后根据法学的信息,找到学院就行,并且离环球影城11km的地方有个海底捞,符合上了.
#hello_net
    这道题纯属使用c#的反编译软件ildasm一打开能看到flag的baby题，没什么好说的捏.



**密码部分我仔细瞎写**
#rsa
    rsa主要有几个量,n,m,c,d,e,p,q
    一般会约定双方都知道的d为私钥,用于解密,所以说有d基本上就能求出明文m,求d也是大部分rsa的难点.
    一般会选择两个非常阴间的素数p和q，然后计算n=pq.于是又有φ（n）=lcm（p-1）(q-1)  并且得到d ≡ e -1 (mod λ ( n )
    进行加密得到c即 c为m^e模n的逆元
    而解密时就是求到m就行了,d可以用于求m（~~忘了怎么算了的捏~~）
##baby_rsa
    这道题有很多个m和c,但是e是相同的且很小.
    不同的模数n中可能存在相同的p或者说q
    求出不同n之间的最大公约数
    得到p或q 可得d
    有私钥d就能得到明文
    经过一番Google这是低加密指数广播攻击,低加密是因为e极小,使用网上给的脚本就能跑出来QAQ(.
    不用把全部的m和c都用上,随便使用几次就能确定d了.
##easy_rsa
    纯属折磨！！！
    ~~这是我做的最久的一道题,甚至可以说是不理智的死磕了~~
    这道题的话m,c,e大得浮夸.但无论如何要先从分解m开始,需要将m分解为两个质因数的乘积,这样的逆运算运算量是很大的.使用短除法之类的用脚本计算可以跑到比赛结束doge,使用yafu，在线网站,rsa tool分解都宣告失败.几近波折发现了wiener attack,可惜网上针对羊城那道题目的脚本在这道题上也基本不适用（这里吐槽一下国内博客各种相互剽窃的行径,浪费我时间）,在yl学长提示下我翻遍了github,找到了一个可以用的脚本，大概是连分数什么的.就是d比较小时使用连分数法可以算出d.
    详细的数学证明应当访问<https://en.wikipedia.org/wiki/Wiener%27s_attack>
    代码如下:
    '''
from collections import deque
from sympy.solvers import solve
from sympy import Symbol

class WeinerAttack:

    expansions = []

    def __init__(self, e, N):
        self.e = e
        self.N = N

    def continued_fraction(self):
        num = self.e
        den = self.N
        while num != 1:
            expansion = num // den
            remainder = num % den
            num = den
            den = remainder
            self.expansions.append(expansion)

    def convergents(self):
        k = deque([0, 1], 2)
        h = deque([1, 0], 2)
        for i, expansion in enumerate(self.expansions[1:]):
            k_new = expansion * k[1] + k[0]
            h_new = expansion * h[1] + h[0]
            k.append(k_new)
            h.append(h_new)

            yield k_new, h_new

    def phi(self):
        for k, h in self.convergents():
            yield (self.e * k - 1) // h

    def solve_poly(self):
        x = Symbol('x')
        for phi in self.phi():
            p = [self.N - phi + 1, self.N]
            roots = solve(x**2 -  p[0]*x + p[1], x)

            if roots[0] * roots[1] == self.N:
                return roots

    def attack(self):
        self.continued_fraction()
        return self.solve_poly()


def main():
    e = 213430058491778540960760024438695043602478507503440169434257192452982713126550143463211986560696072631461520765079924616978705534621300264297689001753491674154760883840909846609800795144777305651106426279144796744740429593882387137111622972666648062225161733733882949499069602323754776638192717411131975351015616681736934546665843369748279104215149629133967947618281790436189006910280067044972668152130796424077182216525946728252724509629272536239924932370930844607
    n = 12159891771013595814091861874421237585413006358206424082455634832926323194345835046235391486976184552133143329591437178662345730209888807650947037014314586234738789951967938911343052092814756499927753883248059955719123797775174845540111932407799514279901643394655797001273023118185654706240750668406507075848502103921454045082847250889333760714185157556161149008265548298639622072127150613477361173938771419295716135315250527713627525487340817084800006139324924120633
    attack = WeinerAttack(e, n)
    factor = attack.attack()

    print('p:', factor[0], '\nq:', factor[1])

if __name__ == '__main__':
    main()
运行后可以得到
p: 8157786915328735316695964080412156345016326373162388966201354262397384063917707519351757045573720193359894766595418350130794340294600225144713656030212381 
q:1490587079219338398046620290641082427994787180296034541527858514000071029343752406735847693977924168828149001457282074522354165319366595790326245635098271773304354653474088493071314680542595377493305415990540332637745850468529896832892079272160975645522917094630190865096266981896643169563810687699889181129753293


接下来应该计算φ（n）通常φ（n）都是由(p-1)*(q-1)得到,然而wiener attack不一样,φ（n）=(p-1)*(q-1)//gmpy2.gcd(p-1,q-1),这点在题目源码当中有体现.
φ（n）求的不同那么私钥d肯定也是不同的.d是e模φ的逆元.即d=gmpy2.invert(e,φ) 但是这道题有点让我迷惑,我使用欧拉函数即φ（n）=(p-1)*(q-1)或者φ（n）=(p-1)*(q-1)//gmpy2.gcd(p-1,q-1)得到的两个不同d均最后解出了明文m,寄，好在不影响,终于得到了flag捏.
针对两种不同的d的实验代码:
n=12159891771013595814091861874421237585413006358206424082455634832926323194345835046235391486976184552133143329591437178662345730209888807650947037014314586234738789951967938911343052092814756499927753883248059955719123797775174845540111932407799514279901643394655797001273023118185654706240750668406507075848502103921454045082847250889333760714185157556161149008265548298639622072127150613477361173938771419295716135315250527713627525487340817084800006139324924120633
d=290109868369597897752306298419599275703
#d=6079945885506797907045930937210618792706503179103212041227817416463161597172917523117695743488092276066571664795718589331172865104944403825473518507157292372075855366314770432361380725866164252570286793606759213930304898852072750893852598280052768177866407622827169859599250382010167669822480171080435988788364395704506827832809431439344568853325659617209392652771972175717445572423126901845284830603040161329214072614809418014437858893285077234695887066663481353183
c=8541318851645545344930243969429110208254565388085191517872761876900839076065069888858514228262306414747946717710205279245215034198965473107281872193488118230733863861616328150112085500328432358109659088247825927281412808489490707737075292549138659022487851598377867926699203115994343831215533955081300618602617070303389413096018280325725402247611090721635884411321425677611344588261611431947370799546061778334598026059784862108006128306767927154553941313401810412831
m=pow(c,d,n)
print(hex(m))
# import gmpy2
# p=8157786915328735316695964080412156345016326373162388966201354262397384063917707519351757045573720193359894766595418350130794340294600225144713656030212381 
# q=1490587079219338398046620290641082427994787180296034541527858514000071029343752406735847693977924168828149001457282074522354165319366595790326245635098271773304354653474088493071314680542595377493305415990540332637745850468529896832892079272160975645522917094630190865096266981896643169563810687699889181129753293
# phi=(p-1)*(q-1)//gmpy2.gcd(p-1,q-1)
# phi=(p-1)*(q-1)
# e=213430058491778540960760024438695043602478507503440169434257192452982713126550143463211986560696072631461520765079924616978705534621300264297689001753491674154760883840909846609800795144777305651106426279144796744740429593882387137111622972666648062225161733733882949499069602323754776638192717411131975351015616681736934546665843369748279104215149629133967947618281790436189006910280067044972668152130796424077182216525946728252724509629272536239924932370930844607
# d=gmpy2.invert(e,phi)
# print(d)








#mia_is_gaming  
    这道题全部的信息就只有一个id和mia is playing games,所以再猜测下找到了whumia的steam账户,账户里什么信息都没有,添加好友当然是不会同意的，库是关上的,账号等级是0,唯一有用的信息是图片和两个曾用名,图片其他mia的题目里也有,所以肯定不是啥特殊信息,就去Google了一下曾用名.找到了github仓库（真有个ins账户名字是maybemia),因为有头像,所以肯定是这个仓库<https://github.com/MaybeMiaaaaaaaa/Flag>,最后当然就是git回溯版本就可以拿到flag了.但是要吐槽一下仓库里文件的嘲讽行为,本来就坐牢,心态顿时更不好啦.