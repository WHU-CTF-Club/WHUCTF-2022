#### Crypto

1、step_in

思路：搜索发现是离散对数加密，用文章附带脚本即可。

exp

```python
from Crypto.Util.number import *
import sympy
import binascii

m = 19473863756169470216761513717236231215537697743280372251145129313170008427811446429449041327395250267747882211273524734095321581248051389974265768691626117243062848801550727373752091141890858527874486642898649244520125776832859761626072343801861069206446551492487339982849621512669210425077834208295662160941
c = 42600578249269264816831356985803772347081052915069067787463640413224330471170684304831936999302635361162979131013334326363549875922393304108167293927952959125033795889496126075700058624102750916948092681065462471622436823768852352471015556980024242505342426801194296670293552172829288531216875890099304565341
n = 2 ** 1024

flag = sympy.discrete_log(n, c, m)
print(long_to_bytes(flag))

#https://blog.csdn.net/Luiino/article/details/126117985
```

参考网址：

https://blog.csdn.net/Luiino/article/details/126117985



2、maybeRSA

思路：由题目描述可以得到hint，即为Paillier加密，然后参考网上代码发现不可以运行，原因是原文中的L函数是浮点型除法，返回浮点数，改为整除得到结果

```python
# -*- coding: utf-8 -*-
from Crypto.Util.number import long_to_bytes,inverse
from sympy import nextprime
from gmpy2 import iroot

def L(x,n):
    return (x-1)//n


n=86324454927461657860007410096336840120979839503674904701948712657586983855807988669560143211912037323769847108631053790908388282060017418955323734615211515597325512546062852172016400460654196227703541549912619998323486704517632234662974095606978779497089776947742868040584904963272448129397635067619098325773
c=1726451157466076433792836196664085910979187016091203310065720429902133572806608113284818027976972190830033290122505577365602531862757450336358643162255821060574358592539799816885970433458408073145090775789065027821803347481834992353713744451853547019182346795544517493138753886389569573107421069710550196774306827161541122709173109834262231098739744078195243391364660744900708109250412707344274544497714183635751450797713917269730241444303399176795175532013203836751964156008402156770232454876185312418767444252495415626026403381106932726330651046682802405218801215363746553285724723893152351473588202746739879107018


#factor(n)
a = iroot(n,2)[0]
p = nextprime(a)
q = n//p
assert p*q == n

#根据解密公式，计算所需私钥对（λ，μ）
Lambda=(p-1)*(q-1)
miu=inverse(Lambda,n*n)
m=(L(pow(c,Lambda,n**2),n)*miu)%n

print long_to_bytes(m)
```

参考网址：

https://www.anquanke.com/post/id/204720